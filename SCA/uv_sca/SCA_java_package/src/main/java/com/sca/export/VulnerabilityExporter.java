package com.sca.export;

import com.sca.config.ConfigLoader;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * 漏洞数据库导出工具
 */
public class VulnerabilityExporter {
    
    private static final String DB_HOST = ConfigLoader.getDbHost();
    private static final String DB_NAME = ConfigLoader.getDbName();
    private static final String DB_USER = ConfigLoader.getDbUser();
    
    private Connection connection;
    
    /**
     * 连接到数据库
     */
    public boolean connect() {
        try {
            // 使用utf8编码，Java MySQL连接器不支持utf8mb4作为characterEncoding参数
            String url = String.format("jdbc:mysql://%s/%s?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=UTC", 
                DB_HOST, DB_NAME);
            String password = ConfigLoader.getDbPassword();
            connection = DriverManager.getConnection(url, DB_USER, password);
            
            if (connection != null && !connection.isClosed()) {
                System.out.println("[+] 成功连接到数据库 " + DB_NAME);
                return true;
            }
        } catch (SQLException e) {
            System.err.println("[!] 数据库连接失败: " + e.getMessage());
        }
        return false;
    }
    
    /**
     * 断开数据库连接
     */
    public void disconnect() {
        if (connection != null) {
            try {
                connection.close();
                System.out.println("[+] 数据库连接已关闭");
            } catch (SQLException e) {
                System.err.println("[!] 关闭连接失败: " + e.getMessage());
            }
        }
    }
    
    /**
     * 导出所有漏洞数据（使用游标分页优化性能）
     */
    public boolean exportAllVulnerabilities(String outputPath, boolean resume) throws Exception {
        if (connection == null || connection.isClosed()) {
            System.err.println("[!] 数据库未连接");
            return false;
        }
        
        // 检查已有文件
        ExportState state = checkExistingFile(outputPath, resume);
        
        // 获取总数
        long totalMappings = getTotalMappings();
        long totalVulnerabilities = getTotalVulnerabilities();
        
        System.out.println("[+] 预计导出: " + totalMappings + " 条映射记录, " + 
            totalVulnerabilities + " 条漏洞记录");
        
        try (FileWriter writer = new FileWriter(outputPath)) {
            // 写入JSON头部
            writer.write("{\n");
            writer.write("  \"export_time\": \"" + LocalDateTime.now().toString() + "\",\n");
            writer.write("  \"export_timestamp\": \"" + 
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmm")) + "\",\n");
            writer.write("  \"mapping_count\": " + totalMappings + ",\n");
            writer.write("  \"vulnerability_count\": " + totalVulnerabilities + ",\n");
            writer.write("  \"mapping_table\": {\n");
            
            // 导出映射表
            System.out.println("[+] 导出映射表（分批处理，使用游标分页优化）...");
            exportMappingTable(writer, state, totalMappings);
            
            writer.write("\n  },\n");
            writer.write("  \"vulnerability_table\": {\n");
            
            // 导出漏洞表
            System.out.println("[+] 导出漏洞表（分批处理，使用游标分页优化）...");
            exportVulnerabilityTable(writer, state, totalVulnerabilities);
            
            writer.write("\n  }\n");
            writer.write("}\n");
            writer.flush();
        }
        
        return true;
    }
    
    private long getTotalMappings() throws SQLException {
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT COUNT(*) as count FROM t_oss_id_purl_map")) {
            if (rs.next()) {
                return rs.getLong("count");
            }
        }
        return 0;
    }
    
    private long getTotalVulnerabilities() throws SQLException {
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT COUNT(*) as count FROM t_origin_vulnerability")) {
            if (rs.next()) {
                return rs.getLong("count");
            }
        }
        return 0;
    }
    
    private void exportMappingTable(FileWriter writer, ExportState state, long totalMappings) 
            throws Exception {
        int batchSize = 10000;
        String lastPurl = null;
        long count = 0;
        boolean first = true;
        
        Map<String, List<String>> batch = new HashMap<>();
        
        while (true) {
            String query;
            if (lastPurl == null) {
                query = "SELECT pk_purl, pk_oss_id FROM t_oss_id_purl_map " +
                       "ORDER BY pk_purl LIMIT ?";
            } else {
                query = "SELECT pk_purl, pk_oss_id FROM t_oss_id_purl_map " +
                       "WHERE pk_purl > ? ORDER BY pk_purl LIMIT ?";
            }
            
            try (PreparedStatement stmt = connection.prepareStatement(query)) {
                if (lastPurl == null) {
                    stmt.setInt(1, batchSize);
                } else {
                    stmt.setString(1, lastPurl);
                    stmt.setInt(2, batchSize);
                }
                
                try (ResultSet rs = stmt.executeQuery()) {
                    boolean hasData = false;
                    while (rs.next()) {
                        hasData = true;
                        String purl = rs.getString("pk_purl");
                        String ossId = rs.getString("pk_oss_id");
                        
                        if (state.resume && state.existingMappings.contains(purl)) {
                            lastPurl = purl;
                            continue;
                        }
                        
                        batch.computeIfAbsent(purl, k -> new ArrayList<>()).add(ossId);
                        count++;
                        lastPurl = purl;
                    }
                    
                    if (!hasData) {
                        break;
                    }
                }
            }
            
            if (count % 50000 == 0) {
                System.out.println("    已处理 " + count + "/" + totalMappings + " 条映射记录...");
            }
            
            if (batch.size() >= 50000) {
                writeMappingBatch(writer, batch, first);
                first = false;
                batch.clear();
                writer.flush();
            }
        }
        
        if (!batch.isEmpty()) {
            writeMappingBatch(writer, batch, first);
        }
        
        System.out.println("[+] 映射表导出完成，共 " + count + " 条映射记录");
    }
    
    private void writeMappingBatch(FileWriter writer, Map<String, List<String>> batch, boolean first) 
            throws IOException {
        for (Map.Entry<String, List<String>> entry : batch.entrySet()) {
            if (!first) {
                writer.write(",\n");
            }
            writer.write("    \"" + escapeJson(entry.getKey()) + "\": " + 
                new com.google.gson.Gson().toJson(entry.getValue()));
            first = false;
        }
    }
    
    private void exportVulnerabilityTable(FileWriter writer, ExportState state, long totalVulnerabilities) 
            throws Exception {
        int batchSize = 10000;
        String lastOssId = null;
        long count = 0;
        boolean first = true;
        
        Map<String, Map<String, Object>> batch = new HashMap<>();
        
        while (true) {
            String query;
            if (lastOssId == null) {
                query = "SELECT oss_id, cve_id, description, severity, cvss_score_v2, " +
                       "cvss_score_v3, cvss_score_v4, source_publish_date as published_date " +
                       "FROM t_origin_vulnerability ORDER BY oss_id LIMIT ?";
            } else {
                query = "SELECT oss_id, cve_id, description, severity, cvss_score_v2, " +
                       "cvss_score_v3, cvss_score_v4, source_publish_date as published_date " +
                       "FROM t_origin_vulnerability WHERE oss_id > ? ORDER BY oss_id LIMIT ?";
            }
            
            try (PreparedStatement stmt = connection.prepareStatement(query)) {
                if (lastOssId == null) {
                    stmt.setInt(1, batchSize);
                } else {
                    stmt.setString(1, lastOssId);
                    stmt.setInt(2, batchSize);
                }
                
                try (ResultSet rs = stmt.executeQuery()) {
                    boolean hasData = false;
                    while (rs.next()) {
                        hasData = true;
                        String ossId = rs.getString("oss_id");
                        
                        if (state.resume && state.existingVulns.contains(ossId)) {
                            lastOssId = ossId;
                            continue;
                        }
                        
                        Map<String, Object> vuln = new HashMap<>();
                        vuln.put("oss_id", ossId);
                        vuln.put("cve_id", rs.getString("cve_id"));
                        vuln.put("description", rs.getString("description"));
                        vuln.put("severity", rs.getString("severity"));
                        vuln.put("cvss_score_v2", rs.getObject("cvss_score_v2"));
                        vuln.put("cvss_score_v3", rs.getObject("cvss_score_v3"));
                        vuln.put("cvss_score_v4", rs.getObject("cvss_score_v4"));
                        java.sql.Date publishedDate = rs.getDate("published_date");
                        vuln.put("published_date", publishedDate != null ? publishedDate.toString() : null);
                        
                        batch.put(ossId, vuln);
                        count++;
                        lastOssId = ossId;
                    }
                    
                    if (!hasData) {
                        break;
                    }
                }
            }
            
            if (count % 50000 == 0) {
                System.out.println("    已处理 " + count + "/" + totalVulnerabilities + " 条漏洞记录...");
            }
            
            if (batch.size() >= 50000) {
                writeVulnBatch(writer, batch, first);
                first = false;
                batch.clear();
                writer.flush();
            }
        }
        
        if (!batch.isEmpty()) {
            writeVulnBatch(writer, batch, first);
        }
        
        System.out.println("[+] 漏洞表导出完成，共 " + count + " 条漏洞记录");
    }
    
    private void writeVulnBatch(FileWriter writer, Map<String, Map<String, Object>> batch, boolean first) 
            throws IOException {
        for (Map.Entry<String, Map<String, Object>> entry : batch.entrySet()) {
            if (!first) {
                writer.write(",\n");
            }
            writer.write("    \"" + escapeJson(entry.getKey()) + "\": " + 
                new com.google.gson.Gson().toJson(entry.getValue()));
            first = false;
        }
    }
    
    private String escapeJson(String str) {
        return str.replace("\\", "\\\\")
                  .replace("\"", "\\\"")
                  .replace("\n", "\\n")
                  .replace("\r", "\\r")
                  .replace("\t", "\\t");
    }
    
    private ExportState checkExistingFile(String filePath, boolean resume) {
        ExportState state = new ExportState();
        state.resume = resume;
        // 简化实现：如果需要断点续传，可以在这里读取已有文件
        // 当前实现为简化版本，暂不支持断点续传
        return state;
    }
    
    private static class ExportState {
        boolean resume = false;
        Set<String> existingMappings = new HashSet<>();
        Set<String> existingVulns = new HashSet<>();
    }
}

